---
slug: cicd-bioinformatics-act-local-github-action
title: "Running GitHub Actions Locally with act: 5x Faster Development"
authors: [river]
tags: [ci-cd, github-actions, docker, bioinformatics, python, devops]
image: ./imgs/intro.png
---

GitHub Actions are powerful for automating bioinformatics pipelines, but waiting 5-10 minutes for each cloud run is painful during development. **`act`** lets you run GitHub Actions workflows **locally on your machine** in seconds, slashing feedback time by 5x.

In this post, we'll explore `act`, a command-line tool that runs GitHub Actions locally using Docker. Perfect for testing ML pipelines, gene expression analysis, and CI/CD workflows before pushing to GitHub.

<!-- truncate -->

## Why Test GitHub Actions Locally?

Traditional GitHub Actions workflow:
1. Write workflow ‚Üí Push to GitHub
2. Wait 5-10 minutes for cloud runner
3. Workflow fails ‚Üí Fix locally ‚Üí Push again
4. Repeat steps 2-3 (multiple times!)

**Total feedback cycle: 30+ minutes for a simple fix**

With `act`:
1. Write workflow
2. Run locally with `act` ‚Üí Instant feedback (10-30 seconds)
3. Debug and iterate locally
4. Push confident code to GitHub

**Total feedback cycle: 5 minutes**

---

## Part 1: Installation and Setup

### Step 1: Install `act`

`act` runs on macOS, Linux, and Windows. Choose your platform:

**macOS (Homebrew - Recommended)**
```bash
brew install act
```

**Linux**
```bash
# Debian/Ubuntu
curl https://raw.githubusercontent.com/nektos/act/master/install.sh | bash

# Or with pacman (Arch)
pacman -S act
```

**Windows (PowerShell)**
```powershell
choco install act
# Or if using Scoop:
scoop install act
```

**Verify Installation**
```bash
act --version
# Output: act version 0.2.X
```

### Step 2: Install Docker

`act` requires Docker to run workflows in containers (just like GitHub's cloud runners).

**macOS/Windows**
- Download [Docker Desktop](https://www.docker.com/products/docker-desktop)
- Install and run

**Linux**
```bash
# Debian/Ubuntu
sudo apt-get install docker.io docker-compose
sudo usermod -aG docker $USER  # Add current user to docker group
newgrp docker  # Activate group changes
```

**Verify Docker**
```bash
docker --version
docker run hello-world  # Should complete successfully
```

### Step 3: Verify Setup

Test that `act` can find your GitHub workflows:

```bash
cd /path/to/your/repo
act --list
```

**Expected output:**
```
Stage  Job ID  Job Name  Workflow Name     Workflow File           Events
0      test    test      test-workflow     .github/workflows/test.yml  push
```

If no workflows appear, ensure `.github/workflows/` exists with `.yml` files.

---

## Part 2: Basic Usage - Running Workflows Locally

### Simple Example: Python Test Workflow

Let's create a minimal GitHub Actions workflow and test it with `act`.

**Create `.github/workflows/test.yml`:**
```yaml
name: Python Tests
on:
  push:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          pip install pytest numpy pandas
      
      - name: Run tests
        run: |
          pytest tests/ -v
```

**Run locally with act:**
```bash
act push
```

**Expected output:**
```
[Python Tests/test] üöÄ Start image pull...
[Python Tests/test] üê≥ Docker pull requested ghcr.io/catthehacker/ubuntu:act-latest
[Python Tests/test] ‚úì Image pull complete
[Python Tests/test] üöÄ Start container...
[Python Tests/test] ‚≠ê Run Main actions/checkout@v3
[Python Tests/test] ‚úì Complete job
```

### Running Specific Workflows

**List all available workflows:**
```bash
act --list
```

**Run a specific job:**
```bash
act --job test
```

**Run a specific workflow:**
```bash
act --workflow test.yml
```

**Simulate a different event (e.g., pull_request):**
```bash
act pull_request
```

---

## Part 3: Environment Variables and Secrets

### Passing Environment Variables

`act` provides several ways to pass variables:

**Method 1: Command-line flag**
```bash
act -e event.json
```

Where `event.json` contains:
```json
{
  "repository": {
    "name": "my-repo",
    "owner": {
      "login": "myusername"
    }
  }
}
```

**Method 2: `.actrc` file** (in repo root)
```bash
# .actrc
-P ubuntu-latest=ghcr.io/catthehacker/ubuntu:act-latest
-l
```

**Method 3: Shell environment variables**
```bash
export MY_VAR="value"
export ANOTHER_VAR="another"
act push
```

### Working with Secrets

GitHub Actions use `secrets` for sensitive data. With `act`, you can pass secrets locally:

**Method 1: `.secrets` file** (in repo root)
```bash
# .secrets
MY_SECRET=super_secret_value
GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
API_KEY=your_api_key_here
```

**Important:** Add `.secrets` to `.gitignore` to prevent committing secrets!
```bash
echo ".secrets" >> .gitignore
```

**Method 2: Command-line secret flag**
```bash
act -s MY_SECRET=value -s GITHUB_TOKEN=token
```

**Workflow using secrets:**
```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Use secret
        run: |
          echo "API Key: ${{ secrets.API_KEY }}"
          echo "Token: ${{ secrets.GITHUB_TOKEN }}"
```

**Run with secrets:**
```bash
act --secret-file .secrets
```

---

## Part 4: Docker and Container Management

### Understanding `act` Container Images

`act` uses pre-built Docker images that mimic GitHub's cloud runners. Default images are large (~15GB) but highly compatible.

**Available Docker images:**
```bash
# Ubuntu (recommended for bioinformatics)
ghcr.io/catthehacker/ubuntu:act-latest

# Debian (smaller, faster)
ghcr.io/catthehacker/ubuntu:full-latest

# Minimal (smallest, fast)
ubuntu:latest  # Docker Hub
```

### Specifying Docker Images

**Method 1: `-P` flag in command**
```bash
act -P ubuntu-latest=ghcr.io/catthehacker/ubuntu:full-latest
```

**Method 2: `.actrc` file**
```bash
# .actrc
-P ubuntu-latest=ghcr.io/catthehacker/ubuntu:full-latest
-P windows-latest=ghcr.io/catthehacker/windows:full-latest
```

**Method 3: Command-line shorthand**
```bash
# Use minimal image
act --container-architecture linux/amd64
```

### Pre-pulling Docker Images

Large images take time on first run. Pre-pull them:

```bash
# Pull the image once
docker pull ghcr.io/catthehacker/ubuntu:act-latest

# Now act will use cached image (much faster)
act push
```

### Managing Disk Space

Docker images consume significant space. Clean up unused images:

```bash
# Remove unused images
docker image prune -a

# Remove all containers
docker container prune -a

# Check disk usage
docker system df
```

---

## Part 5: Performance Optimization Tips

### 1. Use Smaller Docker Images

Instead of full Ubuntu, use minimal images:

**Before (slow - ~15GB):**
```bash
act -P ubuntu-latest=ghcr.io/catthehacker/ubuntu:act-latest
```

**After (fast - ~2GB):**
```bash
act -P ubuntu-latest=ghcr.io/catthehacker/ubuntu:full-latest
```

**Performance impact:** ~2-3x faster

### 2. Cache Dependencies

GitHub Actions support caching. Leverage it in `act`:

**Workflow with caching:**
```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      - name: Install Python dependencies
        run: pip install -r requirements.txt
      
      - name: Run tests
        run: pytest tests/
```

**Performance impact:** First run ~30s, subsequent runs ~5s (cache hit)

### 3. Run Jobs in Parallel

By default, `act` runs jobs sequentially. Enable parallel execution:

```bash
# Run all jobs in parallel
act --parallel 4
```

**Workflow with multiple jobs:**
```yaml
jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - run: pytest tests/unit/
  
  integration-tests:
    runs-on: ubuntu-latest
    steps:
      - run: pytest tests/integration/
  
  lint:
    runs-on: ubuntu-latest
    steps:
      - run: pylint src/
```

**Sequential time:** 30s + 40s + 10s = 80s
**Parallel time (--parallel 3):** ~40s

### 4. Use `act -l` (List) Mode

For quick workflow checks without running:

```bash
act --list
```

Shows all jobs without executing them.

### 5. Rebuild Docker Image

Cache can become stale. Rebuild:

```bash
act --reuse-containers  # Reuse running containers
act --rebuild            # Rebuild image from scratch
```

---

## Real Example: Bioinformatics Gene Expression Pipeline

Let's build a complete ML pipeline workflow and test it locally with `act`.

### Workflow File: `.github/workflows/ml-pipeline.yml`

```yaml
name: ML Pipeline - Gene Expression Analysis
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Cache pip packages
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles('**/requirements.txt') }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-xdist
      
      - name: Lint with pylint
        run: pylint src/ --exit-zero
        continue-on-error: true
      
      - name: Run unit tests
        run: pytest tests/unit/ -v --cov=src --cov-report=xml
      
      - name: Run integration tests
        run: pytest tests/integration/ -v
      
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        if: matrix.python-version == '3.12'
        with:
          files: ./coverage.xml
          flags: unittests
  
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Bandit security check
        run: |
          pip install bandit
          bandit -r src/ -v --exit-code 0
        continue-on-error: true
```

### Running Locally with `act`

**Run all jobs:**
```bash
act push
```

**Expected output:**
```
[ML Pipeline - Gene Expression Analysis/test] üöÄ Start image pull...
[ML Pipeline - Gene Expression Analysis/test] ‚≠ê Run actions/checkout@v3
[ML Pipeline - Gene Expression Analysis/test] ‚úì Step 'Checkout code' completed
[ML Pipeline - Gene Expression Analysis/test] ‚≠ê Run Set up Python 3.10
[ML Pipeline - Gene Expression Analysis/test] ‚úì Step 'Set up Python 3.10' completed
[ML Pipeline - Gene Expression Analysis/test] ‚≠ê Run Install dependencies
[ML Pipeline - Gene Expression Analysis/test] ‚úì Step 'Install dependencies' completed
[ML Pipeline - Gene Expression Analysis/test] ‚≠ê Run Run unit tests
...
[ML Pipeline - Gene Expression Analysis/test] ‚úì Complete job
[ML Pipeline - Gene Expression Analysis/security] ‚≠ê Run Bandit security check
[ML Pipeline - Gene Expression Analysis/security] ‚úì Complete job
```

**Run specific Python version:**
```bash
act push --job test --matrix python-version=3.12
```

**Run only security tests:**
```bash
act push --job security
```

---

## Debugging Workflows with `act`

### Enable Verbose Logging

```bash
act -v push
```

Shows detailed output including Docker commands and environment variables.

### Debug with Interactive Shell

If a step fails, enter the container:

```bash
# Create a failing step
steps:
  - run: |
      echo "Debug info:"
      env | sort
      ls -la
```

Or use `act` with shell access:

```bash
act -b  # Use local container (not rebuilding)
```

### Inspect Container After Failure

Keep container running after failure:

```bash
# View logs
docker ps -a

# Enter the container
docker exec -it <container_id> /bin/bash
```

### Common Issues and Solutions

**Issue: "Cannot connect to Docker daemon"**
```bash
# Solution: Start Docker
sudo systemctl start docker  # Linux
open /Applications/Docker.app  # macOS
```

**Issue: "Not enough space for Docker images"**
```bash
# Solution: Clean up
docker system prune -a --volumes
```

**Issue: "Workflow runs but tests fail locally but pass on GitHub"**
```bash
# Solution: Check Python versions match
python --version
act --list  # Verify Python version in workflow
```

---

## Performance Comparison: Local vs Cloud

| Task | Local (`act`) | GitHub Cloud | Speedup |
|------|--|--|--|
| First run | 45s | 300s+ | 6-7x |
| Subsequent runs (cached) | 8s | 250s+ | 30x |
| Development iteration | 2 min (10 runs) | 50 min | **25x** |
| Cost | $0 | $0.008/min | N/A |

**Key insight:** For a typical development session with 10 iterations, `act` saves 48 minutes of waiting time!

---

## Best Practices for CI/CD with `act`

### 1. **Test Locally Before Pushing**
```bash
# Before git push
act push
# If all pass, then:
git push origin main
```

### 2. **Match GitHub Runner Environment**
```bash
# Use same image as GitHub
act -P ubuntu-latest=ghcr.io/catthehacker/ubuntu:act-latest
```

### 3. **Commit `.actrc` to Repository**
```bash
# .actrc (can be committed)
-P ubuntu-latest=ghcr.io/catthehacker/ubuntu:full-latest
-l
```

But keep `.secrets` in `.gitignore`:
```bash
# .gitignore
.secrets
```

### 4. **Use Matrix Strategy for Multiple Versions**
```yaml
strategy:
  matrix:
    python-version: ['3.10', '3.11', '3.12']
    os: [ubuntu-latest, macos-latest]
```

Test all combinations locally before push.

### 5. **Document Dependencies**
```bash
# requirements.txt
pytest>=7.0.0
numpy>=1.24.0
pandas>=1.5.0
scipy>=1.10.0
```

Keep updated so `act` can replicate exact environment.

---

## Key Takeaways

1. **`act` runs GitHub Actions locally** ‚Üí test before pushing to GitHub
2. **5-30x faster feedback** ‚Üí iterate quickly during development
3. **Docker-based** ‚Üí identical environment to GitHub Cloud runners
4. **Supports secrets and environment variables** ‚Üí test real workflows
5. **Performance optimization** ‚Üí use smaller images, caching, parallel jobs
6. **Free and open-source** ‚Üí no additional costs beyond your machine

---

## What's Next?

Now that you can test workflows locally with `act`, consider:
- Setting up pre-commit hooks to run `act` automatically
- Creating reusable workflow templates for bioinformatics pipelines
- Integrating `act` into your team's development process
- Exploring GitHub Actions Marketplace for bioinformatics tools

---

## References

- [act GitHub Repository](https://github.com/nektos/act)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [Docker Documentation](https://docs.docker.com/)
- [GitHub Actions Best Practices](https://docs.github.com/en/actions/guides)

**Happy local testing! üöÄ**
